import { Directive, HostListener, Renderer, ElementRef, Output, Input, EventEmitter, ContentChildren } from '@angular/core';
import { Subject } from 'rxjs/Subject';
import { merge } from 'rxjs/observable/merge';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/takeUntil';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/pairwise';
import 'rxjs/add/operator/take';
/**
 * @private
 */
var isNumberCloseTo = function (value1, value2, precision) {
    if (precision === void 0) { precision = 3; }
    var diff = Math.abs(value1 - value2);
    return diff < precision;
};
/**
 * @private
 */
var getNewBoundingRectangle = function (startingRect, edges, mouseX, mouseY) {
    var newBoundingRect = {
        top: startingRect.top,
        bottom: startingRect.bottom,
        left: startingRect.left,
        right: startingRect.right
    };
    if (edges.top) {
        newBoundingRect.top += mouseY;
    }
    if (edges.bottom) {
        newBoundingRect.bottom += mouseY;
    }
    if (edges.left) {
        newBoundingRect.left += mouseX;
    }
    if (edges.right) {
        newBoundingRect.right += mouseX;
    }
    newBoundingRect.height = newBoundingRect.bottom - newBoundingRect.top;
    newBoundingRect.width = newBoundingRect.right - newBoundingRect.left;
    return newBoundingRect;
};
var isWithinBoundingY = function (_a) {
    var mouseY = _a.mouseY, rect = _a.rect;
    return mouseY >= rect.top && mouseY <= rect.bottom;
};
var isWithinBoundingX = function (_a) {
    var mouseX = _a.mouseX, rect = _a.rect;
    return mouseX >= rect.left && mouseX <= rect.right;
};
/**
 * @private
 */
var getResizeEdges = function (_a) {
    var mouseX = _a.mouseX, mouseY = _a.mouseY, elm = _a.elm, allowedEdges = _a.allowedEdges;
    var elmPosition = elm.nativeElement.getBoundingClientRect();
    var edges = {};
    if (allowedEdges.left && isNumberCloseTo(mouseX, elmPosition.left) && isWithinBoundingY({ mouseY: mouseY, rect: elmPosition })) {
        edges.left = true;
    }
    if (allowedEdges.right && isNumberCloseTo(mouseX, elmPosition.right) && isWithinBoundingY({ mouseY: mouseY, rect: elmPosition })) {
        edges.right = true;
    }
    if (allowedEdges.top && isNumberCloseTo(mouseY, elmPosition.top) && isWithinBoundingX({ mouseX: mouseX, rect: elmPosition })) {
        edges.top = true;
    }
    if (allowedEdges.bottom && isNumberCloseTo(mouseY, elmPosition.bottom) && isWithinBoundingX({ mouseX: mouseX, rect: elmPosition })) {
        edges.bottom = true;
    }
    return edges;
};
/**
 * @private
 */
var getResizeCursor = function (edges) {
    if (edges.left && edges.top) {
        return 'nw-resize';
    }
    else if (edges.right && edges.top) {
        return 'ne-resize';
    }
    else if (edges.left && edges.bottom) {
        return 'sw-resize';
    }
    else if (edges.right && edges.bottom) {
        return 'se-resize';
    }
    else if (edges.left || edges.right) {
        return 'ew-resize';
    }
    else if (edges.top || edges.bottom) {
        return 'ns-resize';
    }
    else {
        return null;
    }
};
/**
 * @private
 */
var getEdgesDiff = function (_a) {
    var edges = _a.edges, initialRectangle = _a.initialRectangle, newRectangle = _a.newRectangle;
    var edgesDiff = {};
    Object.keys(edges).forEach(function (edge) {
        edgesDiff[edge] = newRectangle[edge] - initialRectangle[edge];
    });
    return edgesDiff;
};
/**
 * An element placed inside a `mwlResizable` directive to be used as a drag and resize handle
 *
 * For example
 *
 * ```
 * <div mwlResizable>
 *   <div mwlResizeHandle [resizeEdges]="{bottom: true, right: true}"></div>
 * </div>
 * ```
 */
export var ResizeHandle = (function () {
    function ResizeHandle() {
        /**
         * The `Edges` object that contains the edges of the parent element that dragging the handle will trigger a resize on
         */
        this.resizeEdges = {};
    }
    /**
     * @private
     */
    ResizeHandle.prototype.onMouseup = function (mouseX, mouseY) {
        this.resizable.mouseup.next({ mouseX: mouseX, mouseY: mouseY, edges: this.resizeEdges });
    };
    /**
     * @private
     */
    ResizeHandle.prototype.onMousedown = function (mouseX, mouseY) {
        this.resizable.mousedown.next({ mouseX: mouseX, mouseY: mouseY, edges: this.resizeEdges });
    };
    /**
     * @private
     */
    ResizeHandle.prototype.onMousemove = function (event) {
        this.resizable.mousemove.next({ mouseX: event.clientX, mouseY: event.clientY, edges: this.resizeEdges, event: event });
    };
    ResizeHandle.decorators = [
        { type: Directive, args: [{
                    selector: '[mwlResizeHandle]'
                },] },
    ];
    /** @nocollapse */
    ResizeHandle.ctorParameters = function () { return []; };
    ResizeHandle.propDecorators = {
        'resizeEdges': [{ type: Input },],
        'onMouseup': [{ type: HostListener, args: ['mouseup', ['$event.clientX', '$event.clientY'],] },],
        'onMousedown': [{ type: HostListener, args: ['mousedown', ['$event.clientX', '$event.clientY'],] },],
        'onMousemove': [{ type: HostListener, args: ['mousemove', ['$event'],] },],
    };
    return ResizeHandle;
}());
/**
 * Place this on an element to make it resizable
 *
 * For example
 *
 * ```
 * <div mwlResizable [resizeEdges]="{bottom: true, right: true, top: true, left: true}" [enableGhostResize]="true"></div>
 * ```
 */
export var Resizable = (function () {
    /**
     * @private
     */
    function Resizable(renderer, elm) {
        this.renderer = renderer;
        this.elm = elm;
        /**
         * The edges that an element can be resized from. Pass an object like `{top: true, bottom: false}`. By default no edges can be resized.
         */
        this.resizeEdges = {};
        /**
         * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.
         */
        this.enableGhostResize = false;
        /**
         * A snap grid that resize events will be locked to.
         *
         * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`
         */
        this.resizeSnapGrid = {};
        /**
         * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.
         */
        this.resizeStart = new EventEmitter(false);
        /**
         * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.
         */
        this.resizing = new EventEmitter(false);
        /**
         * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.
         */
        this.resizeEnd = new EventEmitter(false);
        /**
         * @private
         */
        this.mouseup = new Subject();
        /**
         * @private
         */
        this.mousedown = new Subject();
        /**
         * @private
         */
        this.mousemove = new Subject();
    }
    /**
     * @private
     */
    Resizable.prototype.ngOnInit = function () {
        var _this = this;
        var currentResize;
        var removeGhostElement = function () {
            if (currentResize.clonedNode) {
                _this.elm.nativeElement.parentElement.removeChild(currentResize.clonedNode);
                _this.renderer.setElementStyle(_this.elm.nativeElement, 'visibility', 'inherit');
            }
        };
        this.mousemove.subscribe(function (_a) {
            var mouseX = _a.mouseX, mouseY = _a.mouseY, event = _a.event;
            if (currentResize) {
                event.preventDefault();
            }
            var resizeEdges = getResizeEdges({ mouseX: mouseX, mouseY: mouseY, elm: _this.elm, allowedEdges: _this.resizeEdges });
            var cursor = currentResize ? null : getResizeCursor(resizeEdges);
            _this.renderer.setElementStyle(_this.elm.nativeElement, 'cursor', cursor);
        });
        var mousedrag = this.mousedown.flatMap(function (startCoords) {
            var getDiff = function (moveCoords) {
                return {
                    mouseX: moveCoords.mouseX - startCoords.mouseX,
                    mouseY: moveCoords.mouseY - startCoords.mouseY
                };
            };
            var getSnapGrid = function () {
                var snapGrid = { x: 1, y: 1 };
                if (currentResize) {
                    if (_this.resizeSnapGrid.left && currentResize.edges.left) {
                        snapGrid.x = +_this.resizeSnapGrid.left;
                    }
                    else if (_this.resizeSnapGrid.right && currentResize.edges.right) {
                        snapGrid.x = +_this.resizeSnapGrid.right;
                    }
                    if (_this.resizeSnapGrid.top && currentResize.edges.top) {
                        snapGrid.y = +_this.resizeSnapGrid.top;
                    }
                    else if (_this.resizeSnapGrid.bottom && currentResize.edges.bottom) {
                        snapGrid.y = +_this.resizeSnapGrid.bottom;
                    }
                }
                return snapGrid;
            };
            var getGrid = function (coords, snapGrid) {
                return {
                    x: Math.ceil(coords.mouseX / snapGrid.x),
                    y: Math.ceil(coords.mouseY / snapGrid.y)
                };
            };
            return merge(_this.mousemove.take(1).map(function (coords) { return [, coords]; }), _this.mousemove.pairwise()).map(function (_a) {
                var previousCoords = _a[0], newCoords = _a[1];
                return [previousCoords ? getDiff(previousCoords) : previousCoords, getDiff(newCoords)];
            }).filter(function (_a) {
                var previousCoords = _a[0], newCoords = _a[1];
                if (!previousCoords) {
                    return true;
                }
                var snapGrid = getSnapGrid();
                var previousGrid = getGrid(previousCoords, snapGrid);
                var newGrid = getGrid(newCoords, snapGrid);
                return (previousGrid.x !== newGrid.x || previousGrid.y !== newGrid.y);
            }).map(function (_a) {
                var newCoords = _a[1];
                var snapGrid = getSnapGrid();
                return {
                    mouseX: Math.round(newCoords.mouseX / snapGrid.x) * snapGrid.x,
                    mouseY: Math.round(newCoords.mouseY / snapGrid.y) * snapGrid.y
                };
            }).takeUntil(merge(_this.mouseup, _this.mousedown));
        }).filter(function () { return !!currentResize; });
        mousedrag.map(function (_a) {
            var mouseX = _a.mouseX, mouseY = _a.mouseY;
            return getNewBoundingRectangle(currentResize.startingRect, currentResize.edges, mouseX, mouseY);
        }).filter(function (newBoundingRect) {
            return newBoundingRect.height > 0 && newBoundingRect.width > 0;
        }).filter(function (newBoundingRect) {
            return _this.validateResize ? _this.validateResize({
                rectangle: newBoundingRect,
                edges: getEdgesDiff({
                    edges: currentResize.edges,
                    initialRectangle: currentResize.startingRect,
                    newRectangle: newBoundingRect
                })
            }) : true;
        }).subscribe(function (newBoundingRect) {
            if (currentResize.clonedNode) {
                _this.renderer.setElementStyle(currentResize.clonedNode, 'height', newBoundingRect.height + "px");
                _this.renderer.setElementStyle(currentResize.clonedNode, 'width', newBoundingRect.width + "px");
                _this.renderer.setElementStyle(currentResize.clonedNode, 'top', newBoundingRect.top + "px");
                _this.renderer.setElementStyle(currentResize.clonedNode, 'left', newBoundingRect.left + "px");
            }
            _this.resizing.emit({
                edges: getEdgesDiff({
                    edges: currentResize.edges,
                    initialRectangle: currentResize.startingRect,
                    newRectangle: newBoundingRect
                }),
                rectangle: newBoundingRect
            });
            currentResize.currentRect = newBoundingRect;
        });
        this.mousedown.map(function (_a) {
            var mouseX = _a.mouseX, mouseY = _a.mouseY, edges = _a.edges;
            return edges || getResizeEdges({ mouseX: mouseX, mouseY: mouseY, elm: _this.elm, allowedEdges: _this.resizeEdges });
        }).filter(function (edges) {
            return Object.keys(edges).length > 0;
        }).subscribe(function (edges) {
            if (currentResize) {
                removeGhostElement();
            }
            var startingRect = _this.elm.nativeElement.getBoundingClientRect();
            currentResize = {
                edges: edges,
                startingRect: startingRect,
                currentRect: startingRect
            };
            if (_this.enableGhostResize) {
                currentResize.clonedNode = _this.elm.nativeElement.cloneNode(true);
                _this.elm.nativeElement.parentElement.appendChild(currentResize.clonedNode);
                _this.renderer.setElementStyle(_this.elm.nativeElement, 'visibility', 'hidden');
                _this.renderer.setElementStyle(currentResize.clonedNode, 'position', 'fixed');
                _this.renderer.setElementStyle(currentResize.clonedNode, 'left', currentResize.startingRect.left + "px");
                _this.renderer.setElementStyle(currentResize.clonedNode, 'top', currentResize.startingRect.top + "px");
                _this.renderer.setElementStyle(currentResize.clonedNode, 'height', currentResize.startingRect.height + "px");
                _this.renderer.setElementStyle(currentResize.clonedNode, 'width', currentResize.startingRect.width + "px");
                _this.renderer.setElementStyle(currentResize.clonedNode, 'cursor', getResizeCursor(currentResize.edges));
            }
            _this.resizeStart.emit({
                edges: getEdgesDiff({ edges: edges, initialRectangle: startingRect, newRectangle: startingRect }),
                rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0)
            });
        });
        this.mouseup.subscribe(function () {
            if (currentResize) {
                _this.resizeEnd.emit({
                    edges: getEdgesDiff({
                        edges: currentResize.edges,
                        initialRectangle: currentResize.startingRect,
                        newRectangle: currentResize.currentRect
                    }),
                    rectangle: currentResize.currentRect
                });
                removeGhostElement();
                currentResize = null;
            }
        });
    };
    /**
     * @private
     */
    Resizable.prototype.ngAfterViewInit = function () {
        var _this = this;
        this.resizeHandles.forEach(function (handle) {
            handle.resizable = _this;
        });
    };
    /**
     * @private
     */
    Resizable.prototype.ngOnDestroy = function () {
        this.mousedown.complete();
        this.mouseup.complete();
        this.mousemove.complete();
    };
    /**
     * @private
     */
    Resizable.prototype.onMouseup = function (mouseX, mouseY) {
        this.mouseup.next({ mouseX: mouseX, mouseY: mouseY });
    };
    /**
     * @private
     */
    Resizable.prototype.onMousedown = function (mouseX, mouseY) {
        this.mousedown.next({ mouseX: mouseX, mouseY: mouseY });
    };
    /**
     * @private
     */
    Resizable.prototype.onMousemove = function (event) {
        this.mousemove.next({ mouseX: event.clientX, mouseY: event.clientY, event: event });
    };
    Resizable.decorators = [
        { type: Directive, args: [{
                    selector: '[mwlResizable]'
                },] },
    ];
    /** @nocollapse */
    Resizable.ctorParameters = function () { return [
        { type: Renderer, },
        { type: ElementRef, },
    ]; };
    Resizable.propDecorators = {
        'validateResize': [{ type: Input },],
        'resizeEdges': [{ type: Input },],
        'enableGhostResize': [{ type: Input },],
        'resizeSnapGrid': [{ type: Input },],
        'resizeStart': [{ type: Output },],
        'resizing': [{ type: Output },],
        'resizeEnd': [{ type: Output },],
        'resizeHandles': [{ type: ContentChildren, args: [ResizeHandle,] },],
        'onMouseup': [{ type: HostListener, args: ['document:mouseup', ['$event.clientX', '$event.clientY'],] },],
        'onMousedown': [{ type: HostListener, args: ['document:mousedown', ['$event.clientX', '$event.clientY'],] },],
        'onMousemove': [{ type: HostListener, args: ['document:mousemove', ['$event'],] },],
    };
    return Resizable;
}());
//# sourceMappingURL=resizable.directive.js.map